#+TITLE: Conformance Progress
#+PROPERTY: header-args:sql-mode :product postgres :noweb yes :comments off

* Goal
 Prepare a view of the endpoints per release and how many were hit by conformance tests at the time of that release.  Export this view as json to be used in a graphic visualization.
* Prerequisites
  - our postgres up and running with the included snoopUtils toolset
  - open_api, tests_info, and audit_event tables
  - materalized view stable_endpoint_first
* Data definitions for view
- Endpoints :: endpoints that are part of stable kubernetes and can be considered conformant.
- Conformant :: a stable endpoint that has no vendor-specific need (e.g. volume, where each vendor may satisfy volume in a different way)
- Conformance Test :: a test that has been tagged with '[Conformance]' and is included in kubernetes conformance.yaml doc
- tested endpoint :: an endpoint (from Endpoints) that is hit by a Conformance Test
- endpoint release date :: the first time an endpoint appeared in the open api spec.
- test release date :: the release for a test as defined in the conformance.yamlo
* Build out our tables
  We'll track when endopints are released using the open_api spec, and so we'll need a table that holds the info in these specs.

  We determine tests that hit endpoints using the most recent audit event (as it'll show the test in the useragent that hit the endpoint).  We'll have a table then for the most recent audit event (this assumes that the behaviour of the test hasn't changed since it was introduced, which feels like a safe assumption).

  We want to know when tests were released, which we an grab from the most recent conformance.yaml, so we'll have a table for this info as well.

** open_api
*** Create the table
    The columns are derived from the keys in the open api spec.
   #+NAME: open_api definition
   #+begin_src sql-mode :results silent :tangle ../sql-files/table-open-api.sql
     create table open_api
     (
       release text,
       release_date timestamp,
       endpoint text,
       level text,
       category text,
       path text,
       k8s_group text,
       k8s_version text,
       k8s_kind text,
       k8s_action text,
       deprecated boolean,
       description text,
       spec text,
       primary key (release, endpoint)
     );
   #+end_src
*** Define its loading function
    It's largely going to be a python function, which wed then thread into a plpython3u function

    #+begin_src sql-mode :results silent
    create extension plpython3u;
    #+end_src

   #+NAME: load_open_api.py
   #+BEGIN_SRC python :results silent
     from string import Template
     import json
     import time
     import datetime
     from urllib.request import urlopen, urlretrieve
     from snoopUtils import determine_bucket_job, fetch_swagger
     K8S_REPO_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/"
     OPEN_API_PATH = "/api/openapi-spec/swagger.json"

     release_dates = {
       "v1.0.0": "2015-07-10",
       "v1.1.0": "2015-11-09",
       "v1.2.0": "2016-03-16",
       "v1.3.0": "2016-07-01",
       "v1.4.0": "2016-09-26",
       "v1.5.0": "2016-12-12",
       "v1.6.0": "2017-03-28",
       "v1.7.0": "2017-06-30",
       "v1.8.0": "2017-08-28",
       "v1.9.0": "2017-12-15",
       "v1.10.0": "2018-03-26",
       "v1.11.0":  "2018-06-27",
       "v1.12.0": "2018-09-27",
       "v1.13.0": "2018-12-03" ,
       "v1.14.0": "2019-03-25",
       "v1.15.0": "2019-06-19",
       "v1.16.0": "2019-09-18",
       "v1.17.0": "2019-12-07",
       "v1.18.0": "2020-03-25"
     }
     if custom_release is not None:
       release = custom_release
       open_api_url = K8S_REPO_URL + release + OPEN_API_PATH
       open_api = json.loads(urlopen(open_api_url).read().decode('utf-8')) # may change this to ascii
       rd = release_dates[release]
       release_date = time.mktime(datetime.datetime.strptime(rd, "%Y-%m-%d").timetuple())
     else:
       bucket, job = determine_bucket_job()
       swagger, metadata, commit_hash = fetch_swagger(bucket, job)
       open_api = swagger
       open_api_url = K8S_REPO_URL + commit_hash + OPEN_API_PATH
       release_date = int(metadata['timestamp'])
       release = metadata["version"].split('-')[0].replace('v','')

     sql = Template("""
        WITH open AS (
          SELECT '${open_api}'::jsonb as api_data)
            INSERT INTO open_api(
              release,
              release_date,
              endpoint,
              level,
              category,
              path,
              k8s_group,
              k8s_version,
              k8s_kind,
              k8s_action,
              deprecated,
              description,
              spec
            )
        SELECT
          trim(leading 'v' from '${release}') as release,
          to_timestamp(${release_date}) as release_date,
          (d.value ->> 'operationId'::text) as endpoint,
          CASE
            WHEN paths.key ~~ '%alpha%' THEN 'alpha'
            WHEN paths.key ~~ '%beta%' THEN 'beta'
            ELSE 'stable'
          END AS level,
          split_part((cat_tag.value ->> 0), '_'::text, 1) AS category,
          paths.key AS path,
          ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'group'::text) AS k8s_group,
          ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'version'::text) AS k8s_version,
          ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'kind'::text) AS k8s_kind,
          (d.value ->> 'x-kubernetes-action'::text) AS k8s_action,
          CASE
            WHEN (lower((d.value ->> 'description'::text)) ~~ '%deprecated%'::text) THEN true
            ELSE false
          END AS deprecated,
          (d.value ->> 'description'::text) AS description,
          '${open_api_url}' as spec
          FROM
              open
               , jsonb_each((open.api_data -> 'paths'::text)) paths(key, value)
               , jsonb_each(paths.value) d(key, value)
               , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
         ORDER BY paths.key;
                   """).substitute(release = release,
                                   release_date = release_date,
                                   open_api = json.dumps(open_api).replace("'","''"),
                                   open_api_url = open_api_url)
      #+END_SRC

   #+NAME: load_open_api.sql
   #+BEGIN_SRC sql-mode :results silent :tangle ../sql-files/fn-load_open_api.sql
     set role dba;
     DROP FUNCTION IF EXISTS load_open_api;
     CREATE OR REPLACE FUNCTION load_open_api (
       custom_release text default null
       )
     RETURNS text AS $$
     <<load_open_api.py>>
     try:
       plpy.execute((sql))
       return "{} open api is loaded".format(custom_release if custom_release else "current")
     except:
       return "an error occurred"
     $$ LANGUAGE plpython3u ;
     reset role;
      #+END_SRC
*** Load data into table
    We want to load 1.8 through 1.18, plus current.  Simplest is to do it in two transactions
    #+NAME: load past open_api
    #+begin_src sql-mode :results silent
      with releases as (
        select column1 as release
          from (values
          ('v1.8.0'),
          ('v1.9.0'),
          ('v1.10.0'),
          ('v1.11.0'),
          ('v1.12.0'),
          ('v1.13.0'),
          ('v1.14.0'),
          ('v1.15.0'),
          ('v1.16.0'),
          ('v1.17.0'),
          ('v1.18.0')
          ) as rlist
      )
      select f.*
        from
        releases r
        , lateral load_open_api(r.release) f(loading_results)
      ;
#+end_src

#+begin_src sql-mode :results silent
  select * from load_open_api();
#+end_src
*** Check it worked
    to make our ordering simpler, I added the semver extension https://github.com/theory/pg-semver
    we will need to ensure that this tool is installed in our dockerfile.

#+begin_src sql-mode :results silent
  create extension semver;
#+end_src

#+begin_src sql-mode
  select distinct
    release::semver,
    count(endpoint)
  from open_api
    where level = 'stable'
      and deprecated is false
  group by release
  order by release
    ;
#+end_src

#+RESULTS:
#+begin_SRC example
 release | count
---------+-------
 1.8.0   |   403
 1.9.0   |   481
 1.10.0  |   450
 1.11.0  |   452
 1.12.0  |   373
 1.13.0  |   384
 1.14.0  |   402
 1.15.0  |   402
 1.16.0  |   430
 1.17.0  |   438
 1.18.0  |   445
 1.19.0  |   458
(12 rows)

#+end_SRC

** test
*** Create the table
    Same as the spec, the columns are simply the keys available in the conformance.yaml
    #+NAME: create tests_info table
    #+begin_src sql-mode :results silent :tangle ../sql-files/table-test.sql
      create table test
        (
          testname text,
          codename text,
          release text,
          description text,
          file text
      );
    #+end_src
*** Define its loading function
    So this one is trickier.  We want to be able to map releases of the tests to the releases of the endpoints.  For example, we could see that an endpoint was introduced in 1.11(as defined as when it first appears in the open api spec), and that it is hit by "testFoo".  We could find "testFoo" in our conformance.yaml, see it was released in 1.11 too, and know that the endpoint was introduced with a test.

   The tricky point is that the conformance.yaml release value is versions 1.9 to 1.19 plus an empty string and one called "1.x,1.x".  For the ones that are like '1.8,1.18' it'd make sense to keep the latter version, since it likely reflects when a test went through a significant change.    I am uncertain what to do with the empty string though, as we wouldn't be able to map that to anything and so these tests could easily disappear.

   I did some git searching for some of these tests to see when they were introduced or added to the yaml.  In may cases the test was written 3 years ago, but had a commit of 'promote to conformance' of 1.5 years ago.  Having a commit or pr is not the same as actually promoting.  The only guideline we are using for when a test was deemed conformance was when it appeared in our conformance.yaml and using the release date given in that yaml.  In other words, we need to understand the meaning behind the empty strings.

   In the meantime, I can assign all of them the release value of "1.9", representing the start of conformance.
    #+NAME: load_tests
    #+BEGIN_SRC sql-mode :results silent :tangle ../sql-files/fn-load_tests.sql
      set role dba;
      DROP FUNCTION IF EXISTS load_tests;
      CREATE OR REPLACE FUNCTION load_tests()
      RETURNS text AS $$
      from string import Template
      import json
      import yaml
      from urllib.request import urlopen, urlretrieve

      TESTS_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/master/test/conformance/testdata/conformance.yaml"
      tests = json.dumps(yaml.safe_load(urlopen(TESTS_URL)))
      sql = Template("""
                    WITH jsonb_array AS (
                    SELECT jsonb_array_elements('${tests}'::jsonb) as test_data)
                    INSERT INTO test(testname, codename, release, description, file)
                       SELECT
                       (test_data->>'testname') as testname,
                       (test_data->>'codename') as codename,
                       CASE
                         WHEN ((test_data->>'release') = '') THEN '1.9.0'
                         WHEN ((test_data->>'release') like '%,%')
                           THEN trim(leading 'v' from split_part((test_data->>'release'), ', ', 2))||'.0'
                         ELSE trim(leading 'v' from (test_data->>'release')) ||'.0'
                       END as release,
                       (test_data->>'description') as description,
                       (test_data->>'file') as file
                       from jsonb_array;
                    """).substitute(tests = tests.replace("'","''"))
      try:
          plpy.execute(sql)
          return 'conformance.yaml loaded into test!'
      except Exception as e:
          return 'error occured: ', e
      $$ LANGUAGE plpython3u ;
      reset role;
       #+END_SRC
*** Load data into table
    #+NAME: Load test_info
    #+begin_src sql-mode :results silent
    select * from load_tests();
    #+end_src
*** Alter empty string events
    If we take a look at the distinct releases
    #+begin_src sql-mode
      select distinct
        release, count(test)
      from test
      group by release;
    #+end_src

    #+RESULTS:
    #+begin_SRC example
     release | count
    ---------+-------
             |    17
     1.12.0  |    11
     1.13.0  |    13
     1.14.0  |     2
     1.15.0  |    16
     1.16.0  |    55
     1.17.0  |     4
     1.18.0  |     7
     1.19.0  |    21
     1.9.0   |   149
    (10 rows)

    #+end_SRC
    We can see that the empty string is responsible for 17 tests, which is not insiginificant.  The tests are:

    #+begin_src sql-mode
    select testname from test where release = '';
    #+end_src

    #+RESULTS:
    #+begin_SRC example
                     testname
    ------------------------------------------
     aggregator-supports-the-sample-apiserver
     namespace-deletion-removes-pods
     namespace-deletion-removes-services
     watch-configmaps-from-resource-version
     watch-configmaps-closed-and-restarted
     watch-configmaps-with-multiple-watchers
     watch-configmaps-label-changed
     DaemonSet-FailedPodCreation
     DaemonSet-Rollback
     DaemonSet-NodeSelection
     DaemonSet-Creation
     DaemonSet-RollingUpdate
     Deployment Recreate
     Deployment RollingUpdate
     Deployment RevisionHistoryLimit
     Deployment Proportional Scaling
     Deployment Rollover
    (17 rows)
    #+end_SRC

    This is likely really 5 test files, where multiple tests were generatedfrom one gingko function (e.g. different types of parameers given to the watch-configmaps function).

    The earlest release in the conformance.yaml is 1.9, and so if we set all these to 1.8, they'll be distinct and easy to call up later.

    #+begin_src sql-mode
      update test
        set release='1.8.0'
      where release = '';
    #+end_src

    #+RESULTS:
    #+begin_SRC example
    UPDATE 17
    #+end_SRC

** audit event
*** Create the table
 #+NAME: audit_event
 #+BEGIN_SRC sql-mode :results silent :tangle ../sql-files/table-audit_event.sql
   CREATE UNLOGGED TABLE audit_event (
     release text,
     release_date text,
     audit_id text NOT NULL,
     endpoint text,
     useragent text,
     test text,
     test_hit boolean,
     conf_test_hit boolean,
     data jsonb NOT NULL,
     id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
     ingested_at timestamp DEFAULT CURRENT_TIMESTAMP
   );
 #+END_SRC
*** Define its loading function
     #+NAME: load_audit_events.sql
     #+BEGIN_SRC sql-mode :noweb yes :results silent :tangle ../sql-files/fn-load_audit_events.sql
       set role dba;
       CREATE OR REPLACE FUNCTION load_audit_events(
         custom_bucket text default null,
         custom_job text default null)
         RETURNS text AS $$
         from string import Template
         from snoopUtils import determine_bucket_job, download_and_process_auditlogs, fetch_swagger

         bucket, job = determine_bucket_job(custom_bucket, custom_job)
         auditlog_file = download_and_process_auditlogs(bucket, job)
         _, metadata, _ = fetch_swagger(bucket, job)
         release_date = int(metadata['timestamp'])
         release = metadata["version"].split('-')[0].replace('v','')

         sql = Template("""
           CREATE TEMPORARY TABLE audit_event_import(data jsonb not null) ;
           COPY audit_event_import(data)
           FROM '${audit_logfile}' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');

           INSERT INTO audit_event(release, release_date,
                                   audit_id, endpoint,
                                   useragent, test,
                                   test_hit, conf_test_hit,
                                   data)

           SELECT trim(leading 'v' from '${release}') as release,
                   '${release_date}',
                   (raw.data ->> 'auditID'),
                   (raw.data ->> 'operationId') as endpoint,
                   (raw.data ->> 'userAgent') as useragent,
                   CASE
                     WHEN ((raw.data ->> 'userAgent') like 'e2e.test%')
                       THEN trim(split_part((raw.data->>'userAgent'), '--'::text, 2))
                     ELSE null
                   END as test,
                   ((raw.data ->> 'userAgent') like 'e2e.test%') as test_hit,
                   ((raw.data ->> 'userAgent') like '%[Conformance]%') as conf_test_hit,
                   raw.data
             FROM audit_event_import raw;
                   """).substitute(
                       audit_logfile = auditlog_file,
                       release = release,
                       release_date = release_date,
                   )
         try:
             plpy.execute(sql)
             return "it worked"
         except plpy.SPIError as plpyError:
             print("something went wrong with plpy: ")
             return plpyError
         except:
             return "something unknown went wrong"
         $$ LANGUAGE plpython3u ;
         reset role;
     #+END_SRC
*** Load data into table
    #+begin_src sql-mode
  select * from load_audit_events();
    #+end_src

    #+RESULTS:
    #+begin_SRC example
     load_audit_events
    -------------------
     it worked
    (1 row)

    #+end_SRC
* Create stable_endpoint_first materialized view
  This will be the crux of our work.  We can combine our three tables to see every endpoint and the tests that hit it.  If we then make lists of the rleease dates for these tests, sorted by semver, then we can see when an endpoint is first hit by a conformance test.  In the same way, we can make a sorted list of the endpoints apperance in an open api spec to see when it is first released.

  #+NAME: define stable_endpoint_first
  #+begin_src sql-mode :results silent :tangle ../sql-files/matview-stable_endpoint_first.sql
    create materialized view stable_endpoint_first as
    select distinct
      oa.endpoint,
      (array_agg(test.release order by test.release::semver))[1] as first_conformance_test,
      (array_agg(test.testname order by test.release::semver))[1] as test,
      (array_agg(test.codename order by test.release::semver))[1] as codename,
      (array_agg(test.file order by test.release::semver))[1] as file,
      (array_agg(oa.release order by oa.release::semver))[1] as first_release,
      array_remove((array_agg(distinct test.release::semver order by test.release::semver)), null) as all_test_releases
      from
          open_api oa
          left join audit_event ae using(endpoint)
          left join test on (ae.test = test.codename)
      where oa.level = 'stable'
      and deprecated is false
      group by 1
      ;
  #+end_src
* Explore stable endpoint first

 I wanted to see the spread of values for the first_conformance_test results
 #+NAME: distinct first conformance test releases
 #+begin_src sql-mode
   select distinct
     first_conformance_test::semver
   from stable_endpoint_first
   where first_conformance_test is not null
   order by first_conformance_test::semver
   ;
 #+end_src

 #+RESULTS: distinct first conformance test releases
 #+begin_SRC example
  first_conformance_test
 ------------------------
  1.8.0
  1.9.0
  1.13.0
  1.15.0
  1.16.0
  1.17.0
  1.18.0
  1.19.0
 (8 rows)

 #+end_SRC

 So this is interesting to me.  According to our view, there were no tests introduced in 1.11, 1.12, or 1.14 that hit an untested endpoint.   How many tests were introduced in these releaes?


  #+begin_src sql-mode
  select distinct all_test_releases from stable_endpoint_first where all_test_releases @> array['1.12.0'::semver];
  #+end_src

  #+RESULTS:
  #+begin_SRC example
                               all_test_releases
  ----------------------------------------------------------------------------
   {1.9.0,1.12.0,1.13.0,1.15.0,1.19.0,NULL}
   {1.8.0,1.9.0,1.12.0,1.16.0,NULL}
   {1.8.0,1.9.0,1.12.0,1.13.0,1.15.0,1.16.0,1.19.0,NULL}
   {1.8.0,1.9.0,1.12.0,1.13.0,1.15.0,1.16.0,1.18.0,NULL}
   {1.8.0,1.9.0,1.12.0,1.13.0,1.14.0,1.15.0,1.16.0,NULL}
   {1.8.0,1.9.0,1.12.0,1.13.0,1.14.0,1.15.0,1.16.0,1.17.0,1.18.0,1.19.0,NULL}
   {1.9.0,1.12.0,1.13.0,1.14.0,1.15.0,1.16.0,1.17.0,1.18.0,1.19.0,NULL}
  (7 rows)

  #+end_SRC


 #+begin_src sql-mode
   select
   release,
   count(test)
   from test
   where release = any('{"1.12.0", "1.11.0", "1.14.0"}')
   group by release
   ;
 #+end_src

 #+RESULTS:
 #+begin_SRC example
  release | count
 ---------+-------
  1.12.0  |    11
  1.14.0  |     2
 (2 rows)

 #+end_SRC

 So there were no conformance tests introduced in 1.11, only a couple in 1.14, and the ones introduced in 1.12 only hit previously covered endpoints?  Could that be true?
 One way we could check is by looking at the list of test_releases from stable_endpoint_first where the list includes 1.12 or 1.14.  My concern is that these lists would show our pseudo release 1.8 as the front, and then 1.12...and since we don't know the exact date of 1.8 tests, there mgiht've been cases when a 1.12 release really did touch an untested endpoilknt first.

#+NAME: test releases that include 1.12
#+begin_src sql-mode
  select distinct
    all_test_releases
    from stable_endpoint_first
    where all_test_releases @> array['1.12.0'::semver]
    or all_test_releases @> array['1.14.0'::semver]
    ;
#+end_src

#+RESULTS: test releases that include 1.12
#+begin_SRC example
                           all_test_releases
-----------------------------------------------------------------------
 {1.9.0,1.12.0,1.13.0,1.15.0,1.19.0}
 {1.8.0,1.9.0,1.12.0,1.13.0,1.14.0,1.15.0,1.16.0,1.17.0,1.18.0,1.19.0}
 {1.8.0,1.9.0,1.12.0,1.13.0,1.15.0,1.16.0,1.19.0}
 {1.8.0,1.9.0,1.12.0,1.13.0,1.15.0,1.16.0,1.18.0}
 {1.8.0,1.9.0,1.12.0,1.13.0,1.14.0,1.15.0,1.16.0}
 {1.8.0,1.9.0,1.12.0,1.16.0}
 {1.9.0,1.14.0,1.15.0,1.17.0}
 {1.9.0,1.12.0,1.13.0,1.14.0,1.15.0,1.16.0,1.17.0,1.18.0,1.19.0}
(8 rows)

#+end_SRC

So here we can see 1.8 in the front for some, but always with 1.9 after...so even if we were to factor those out, there isn't a known case where a 1.12 or 1.14 test covered a previously uncovered endpoint.
1.11 had no conformance tests.  The dips I was seeing doin't seem to be an issue with the sql query, they were legitimate lags in new coverage.

* Track conformance progress
  So now we can build out our conformance progess, showoing the endpoints per release and the tests per release.

  #+NAME: conformance progress
  #+begin_src sql-mode
    with current_stable_endpoints as (
      select endpoint
        from open_api
       where release = '1.19.0'
         and level = 'stable'
      except
        select endpoint
        from open_api
        where path like '%volume%'
            or path like '%storage%'
            or deprecated is true
            or k8s_kind = 'ComponentStatus'
            or (k8s_kind = 'Node' and k8s_action = any('{"delete", "post"}'))
    ), endpoints_per_release as (-- this filters out endpoints that were dropped after the release
      select release, endpoint
        from       open_api
        inner join current_stable_endpoints using(endpoint)
    )
    select distinct
      epr.release::semver,
      count(*) filter (where epr.release = firsts.first_release) as new_endpoints,
      (select count(*) from test where test.release = epr.release) as new_tests,
      count(*) filter (
        where epr.release = firsts.first_release
        and firsts.all_test_releases @> array[epr.release::semver]
      ) as new_endpoints_promoted_with_tests,
      count(*) filter (
        where epr.release = firsts.first_release
        and firsts.first_conformance_test = firsts.first_release
      ) as new_endpoints_covered_by_new_tests,
      count(*) filter (
      where firsts.first_release = epr.release
      and firsts.first_conformance_test::semver < epr.release::semver
      ) new_endpoints_covered_by_old_tests,
      count(*) filter (
        where firsts.first_release::semver < epr.release::semver
          and firsts.first_conformance_test = epr.release
      ) old_endpoints_covered_by_new_tests,
      count(*) as total_endpoints,
      count(*) filter (
        where firsts.first_release::semver <= epr.release::semver
        and firsts.first_conformance_test::semver <= epr.release::semver
      ) as total_tested_endpoints,
      count(*) filter (
        where firsts.first_release = epr.release
        AND firsts.first_conformance_test is null
      ) endpoints_still_untested_today
      from
          endpoints_per_release epr
            left join stable_endpoint_first firsts on (epr.endpoint = firsts.endpoint)
     group by epr.release
        order by epr.release::semver
              ;
    #+end_src

    #+RESULTS: conformance progress
    #+begin_SRC example
    CREATE VIEW
    #+end_SRC

  This is not the most optimized query, most likely, but it works!
  What we are looking at is the # of endpoints released per version, how many of them came in with a test that covered them, and how many of them came in covered by an old test.
  if there are endpoints that did not come in with a test, but are covered by an old one, they may be good to revisit as that old test may not meaningfully cover this new endpoint.

  We also take a look at the new tests that were releases with each version and how many old endopints are hit by these new tests.  It is often the case that a conformance test will be brought in v.1.13 or v1.18 to cover an enpdoint introduced in 1.9.  This now shows that part of testing work.

  For a sanity check, the columns "new endpoints covered by new tests", "new endpoints covered by old tests", "old endpoints covered by new tests" and the previous row's "total tested endpoints" should add up to the current row's total tested endpoints.
  I can confirm that this is the case.


  Similarly, the sum of the column "stable endopints" less the sum of the column "new endoints still untested" should equal the total tested endpoints for 1.19.  I can confirm that it does.

 I then save this view as "stable_conformance_progress" so that it will be easier to output as json

  #+NAME: conformance progress
  #+begin_src sql-mode :tangle ../sql-files/view-conformance_progress.sql
    create view stable_conformance_progress as
      with current_stable_endpoints as (
        select endpoint
          from open_api
         where release = '1.19.0'
           and level = 'stable'
        except
          select endpoint
          from open_api
          where path like '%volume%'
              or path like '%storage%'
              or deprecated is true
              or k8s_kind = 'ComponentStatus'
              or (k8s_kind = 'Node' and k8s_action = any('{"delete", "post"}'))
      ), endpoints_per_release as (-- this filters out endpoints that were dropped after the release
        select release, endpoint
          from       open_api
          inner join current_stable_endpoints using(endpoint)
      )
      select distinct
        epr.release::semver,
        count(*) filter (where epr.release = firsts.first_release) as new_endpoints,
        (select count(*) from test where test.release = epr.release) as new_tests,
        count(*) filter (
          where epr.release = firsts.first_release
          and firsts.all_test_releases @> array[epr.release::semver]
        ) as new_endpoints_promoted_with_tests,
        count(*) filter (
          where epr.release = firsts.first_release
          and firsts.first_conformance_test = firsts.first_release
        ) as new_endpoints_covered_by_new_tests,
        count(*) filter (
        where firsts.first_release = epr.release
        and firsts.first_conformance_test::semver < epr.release::semver
        ) new_endpoints_covered_by_old_tests,
        count(*) filter (
          where firsts.first_release::semver < epr.release::semver
            and firsts.first_conformance_test = epr.release
        ) old_endpoints_covered_by_new_tests,
        count(*) as total_endpoints,
        count(*) filter (
          where firsts.first_release::semver <= epr.release::semver
          and firsts.first_conformance_test::semver <= epr.release::semver
        ) as total_tested_endpoints,
        count(*) filter (
          where firsts.first_release = epr.release
          AND firsts.first_conformance_test is null
        ) endpoints_still_untested_today
      from      endpoints_per_release epr
      left join stable_endpoint_first firsts on (epr.endpoint = firsts.endpoint)
      group by epr.release
      order by epr.release::semver;
    #+end_src
* Output stable_conformance_progress to json
  We can do this with a psql script.  We turn off alignment and turn on tuples (to remove the header and just have it as pure json) then output it to a file.  easy peasy!

  #+begin_src shell
  pwd
  #+end_src

  #+RESULTS:
  #+begin_example
  /home/zz/snoop/reports
  #+end_example

#+begin_src sql-mode :tangle progress-to-json.sql
  begin;
  \t
  \a
  \o ../resources/coverage/conformance-progress.json
    select json_agg(json_build_object(
    'release', release,
    'total', json_build_object(
      'endpoints', total_endpoints,
      'tested', total_tested_endpoints,
      'new', new_endpoints,
      'new_with_tests', new_endpoints_promoted_with_tests,
      'new_tested', new_endpoints_covered_by_new_tests + new_endpoints_covered_by_old_tests,
      'still_untested', endpoints_still_untested_today
    )
   ))from stable_conformance_progress;
  \o
  \a
  \t
  commit;
#+end_src

#+RESULTS:
#+begin_SRC example
BEGIN
Tuples only is on.
Output format is unaligned.
#+end_SRC

That will look now like so
#+begin_src shell
  cat progress2.json | jq .
#+end_src

#+RESULTS:
#+begin_example
[
  {
    "release": "1.8.0",
    "total": {
      "endpoints": 273,
      "tested": 36,
      "new": 273,
      "new_with_tests": 36,
      "new_tested": 36,
      "still_untested": 183
    }
  },
  {
    "release": "1.9.0",
    "total": {
      "endpoints": 336,
      "tested": 68,
      "new": 63,
      "new_with_tests": 10,
      "new_tested": 14,
      "still_untested": 46
    }
  },
  {
    "release": "1.10.0",
    "total": {
      "endpoints": 345,
      "tested": 72,
      "new": 9,
      "new_with_tests": 0,
      "new_tested": 4,
      "still_untested": 5
    }
  },
  {
    "release": "1.11.0",
    "total": {
      "endpoints": 347,
      "tested": 72,
      "new": 2,
      "new_with_tests": 0,
      "new_tested": 0,
      "still_untested": 2
    }
  },
  {
    "release": "1.12.0",
    "total": {
      "endpoints": 348,
      "tested": 72,
      "new": 1,
      "new_with_tests": 0,
      "new_tested": 0,
      "still_untested": 1
    }
  },
  {
    "release": "1.13.0",
    "total": {
      "endpoints": 348,
      "tested": 73,
      "new": 0,
      "new_with_tests": 0,
      "new_tested": 0,
      "still_untested": 0
    }
  },
  {
    "release": "1.14.0",
    "total": {
      "endpoints": 366,
      "tested": 75,
      "new": 18,
      "new_with_tests": 0,
      "new_tested": 2,
      "still_untested": 9
    }
  },
  {
    "release": "1.15.0",
    "total": {
      "endpoints": 366,
      "tested": 82,
      "new": 0,
      "new_with_tests": 0,
      "new_tested": 0,
      "still_untested": 0
    }
  },
  {
    "release": "1.16.0",
    "total": {
      "endpoints": 394,
      "tested": 121,
      "new": 28,
      "new_with_tests": 26,
      "new_tested": 26,
      "still_untested": 2
    }
  },
  {
    "release": "1.17.0",
    "total": {
      "endpoints": 402,
      "tested": 128,
      "new": 8,
      "new_with_tests": 0,
      "new_tested": 0,
      "still_untested": 8
    }
  },
  {
    "release": "1.18.0",
    "total": {
      "endpoints": 409,
      "tested": 137,
      "new": 7,
      "new_with_tests": 0,
      "new_tested": 0,
      "still_untested": 7
    }
  },
  {
    "release": "1.19.0",
    "total": {
      "endpoints": 423,
      "tested": 160,
      "new": 14,
      "new_with_tests": 14,
      "new_tested": 14,
      "still_untested": 0
    }
  }
]
#+end_example

easy peasy!

Next up is visualizing this in a nice set of bar charts.  I'll cover that in a clojure/vega-lite function outside of this report.

* see which tests hit which endoints
#+begin_src sql-mode
  select
  endpoint,
  test.testname,
  test.file,
  test.release
  from       stable_endpoint_first
  left  join audit_event using(endpoint)
  inner join test on (test.codename = audit_event.test)
     where first_release = '1.19.0'
  order by endpoint
   ;
#+end_src

#+RESULTS:
#+begin_SRC example
                        endpoint                         |                 testname                 |                file                 | release
---------------------------------------------------------+------------------------------------------+-------------------------------------+---------
 createCertificatesV1CertificateSigningRequest           | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 createCertificatesV1CertificateSigningRequest           | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 createCertificatesV1CertificateSigningRequest           | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 deleteCertificatesV1CertificateSigningRequest           | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 deleteCertificatesV1CollectionCertificateSigningRequest | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 getCertificatesV1APIResources                           | aggregator-supports-the-sample-apiserver | test/e2e/apimachinery/aggregator.go | 1.8.0
 getCertificatesV1APIResources                           | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 listCertificatesV1CertificateSigningRequest             | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 listCertificatesV1CertificateSigningRequest             | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 listCertificatesV1CertificateSigningRequest             | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 listCertificatesV1CertificateSigningRequest             | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 listCertificatesV1CertificateSigningRequest             | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 patchCertificatesV1CertificateSigningRequest            | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 patchCertificatesV1CertificateSigningRequestApproval    | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 patchCertificatesV1CertificateSigningRequestStatus      | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 readCertificatesV1CertificateSigningRequest             | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 readCertificatesV1CertificateSigningRequest             | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 readCertificatesV1CertificateSigningRequestApproval     | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 readCertificatesV1CertificateSigningRequestStatus       | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 replaceCertificatesV1CertificateSigningRequest          | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 replaceCertificatesV1CertificateSigningRequestApproval  | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
 replaceCertificatesV1CertificateSigningRequestStatus    | CertificateSigningRequest API            | test/e2e/auth/certificates.go       | 1.19.0
(22 rows)

#+end_SRC

#+begin_src shell
  pwd
#+end_src

#+RESULTS:
#+begin_example
/home/zz/snoop/reports
#+end_example

* Footnotes
** Scratch
   #+begin_src sql-mode
     select release, total_endpoints, total_tested_endpoints
         from conformance_progress;
   #+end_src

   #+RESULTS:
   #+begin_SRC example
    release | total_endpoints | total_tested_endpoints
   ---------+-----------------+------------------------
    1.8.0   |             264 |                      0
    1.9.0   |             327 |                     67
    1.10.0  |             336 |                     71
    1.11.0  |             338 |                     71
    1.12.0  |             339 |                     71
    1.13.0  |             339 |                     72
    1.14.0  |             357 |                     74
    1.15.0  |             357 |                     81
    1.16.0  |             385 |                    120
    1.17.0  |             386 |                    127
    1.18.0  |             386 |                    136
    1.19.0  |             418 |                    159
   (12 rows)

   #+end_SRC


   #+begin_src sql-mode
  \d+
   #+end_src

   #+RESULTS:
   #+begin_SRC example
   Did not find any relations.
   #+end_SRC
#+begin_src sql-mode
  select json_build_object(
  'release', release,
  'totals', json_build_object(
   'total endpoints', total_endpoints,
   'tested endpoints', total_tested_endpoints
  ))
  from stable_conformance_progress;
#+end_src

#+RESULTS:
#+begin_SRC example
                                   json_build_object
----------------------------------------------------------------------------------------
 {"release" : "1.8.0", "totals" : {"total endpoints" : 273, "tested endpoints" : 36}}
 {"release" : "1.9.0", "totals" : {"total endpoints" : 336, "tested endpoints" : 68}}
 {"release" : "1.10.0", "totals" : {"total endpoints" : 345, "tested endpoints" : 72}}
 {"release" : "1.11.0", "totals" : {"total endpoints" : 347, "tested endpoints" : 72}}
 {"release" : "1.12.0", "totals" : {"total endpoints" : 348, "tested endpoints" : 72}}
 {"release" : "1.13.0", "totals" : {"total endpoints" : 348, "tested endpoints" : 73}}
 {"release" : "1.14.0", "totals" : {"total endpoints" : 366, "tested endpoints" : 75}}
 {"release" : "1.15.0", "totals" : {"total endpoints" : 366, "tested endpoints" : 82}}
 {"release" : "1.16.0", "totals" : {"total endpoints" : 394, "tested endpoints" : 121}}
 {"release" : "1.17.0", "totals" : {"total endpoints" : 402, "tested endpoints" : 128}}
 {"release" : "1.18.0", "totals" : {"total endpoints" : 409, "tested endpoints" : 137}}
 {"release" : "1.19.0", "totals" : {"total endpoints" : 423, "tested endpoints" : 160}}
(12 rows)

#+end_SRC

#+begin_src sql-mode :results silent
  begin;
  \t
  \a
  \o progress2.json
  select json_agg(progress) from (
       select * from stable_conformance_progress)
  progress;
  \o
  \a
  \t
  commit;
#+end_src

#+begin_src sql-mode
    select json_agg(progress) from (
  select json_build_object('release', release)
       from stable_conformance_progress
  ) progress;
#+end_src

#+RESULTS:
#+begin_SRC example
                    json_agg
-------------------------------------------------
 [{"json_build_object":{"release" : "1.8.0"}},  +
  {"json_build_object":{"release" : "1.9.0"}},  +
  {"json_build_object":{"release" : "1.10.0"}}, +
  {"json_build_object":{"release" : "1.11.0"}}, +
  {"json_build_object":{"release" : "1.12.0"}}, +
  {"json_build_object":{"release" : "1.13.0"}}, +
  {"json_build_object":{"release" : "1.14.0"}}, +
  {"json_build_object":{"release" : "1.15.0"}}, +
  {"json_build_object":{"release" : "1.16.0"}}, +
  {"json_build_object":{"release" : "1.17.0"}}, +
  {"json_build_object":{"release" : "1.18.0"}}, +
  {"json_build_object":{"release" : "1.19.0"}}]
(1 row)

#+end_SRC

#+begin_src sql-mode
select * from stable_conformance_progress;
#+end_src

#+RESULTS:
#+begin_SRC example
 release | new_endpoints | new_tests | new_endpoints_promoted_with_tests | new_endpoints_covered_by_new_tests | new_endpoints_covered_by_old_tests | old_endpoints_covered_by_new_tests | total_endpoints | total_tested_endpoints | endpoints_still_untested_today
---------+---------------+-----------+-----------------------------------+------------------------------------+------------------------------------+------------------------------------+-----------------+------------------------+--------------------------------
 1.8.0   |           264 |         0 |                                 0 |                                  0 |                                  0 |                                  0 |             264 |                      0 |                            166
 1.9.0   |            63 |       166 |                                21 |                                 21 |                                  0 |                                 61 |             327 |                     82 |                             39
 1.10.0  |             9 |         0 |                                 0 |                                  0 |                                  4 |                                  0 |             336 |                     86 |                              5
 1.11.0  |             2 |         0 |                                 0 |                                  0 |                                  0 |                                  0 |             338 |                     86 |                              2
 1.12.0  |             1 |        11 |                                 0 |                                  0 |                                  0 |                                  0 |             339 |                     86 |                              1
 1.13.0  |             0 |        13 |                                 0 |                                  0 |                                  0 |                                  1 |             339 |                     87 |                              0
 1.14.0  |            18 |         2 |                                 0 |                                  0 |                                  2 |                                  0 |             357 |                     89 |                              7
 1.15.0  |             0 |        16 |                                 0 |                                  0 |                                  0 |                                  7 |             357 |                     96 |                              0
 1.16.0  |            28 |        55 |                                26 |                                 22 |                                  4 |                                 11 |             385 |                    133 |                              2
 1.17.0  |             1 |         4 |                                 0 |                                  0 |                                  0 |                                  7 |             386 |                    140 |                              1
 1.18.0  |             0 |         7 |                                 0 |                                  0 |                                  0 |                                 10 |             386 |                    150 |                              0
 1.19.0  |            32 |        23 |                                31 |                                 30 |                                  1 |                                 13 |             418 |                    194 |                              1
(12 rows)

#+end_SRC

#+begin_src sql-mode
    select stable.endpoint,
  count(*) filter (where test_hit is true)
           from stable_endpoint_first stable
         left join audit_event using (endpoint)
     where first_release = '1.19.0'
         group by stable.endpoint
     order by count
  ;
#+end_src
