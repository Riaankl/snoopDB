#+TITLE: Get Operations and Their Tests
#+PROPERTY: header-args:sql-mode :product postgres :noweb yes

* Purpose

* Setup
** Create tables
   will be filled with the swagger.json, in other words these are the endpoints that are part of the current k8s api
   #+NAME: create open_api table
   #+begin_src sql-mode :results silent
     create table open_api
     (
       release text,
       release_date timestamp,
       endpoint text,
       level text,
       category text,
       path text,
       k8s_group text,
       k8s_version text,
       k8s_kind text,
       k8s_action text,
       deprecated boolean,
       description text,
       spec text,
       primary key (release, endpoint)
     );
   #+end_src

    #+NAME: create tests_info table
    #+begin_src sql-mode :results silent
      create table test_info
        (
          testname text,
          codename text,
          release text,
          description text,
          file text
      );
    #+end_src

 #+NAME: audit_event
 #+BEGIN_SRC sql-mode :results silent
   CREATE UNLOGGED TABLE audit_event (
     release text,
     release_date text,
     audit_id text NOT NULL,
     endpoint text,
     useragent text,
     test text,
     test_hit boolean,
     conf_test_hit boolean,
     data jsonb NOT NULL,
     id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
     ingested_at timestamp DEFAULT CURRENT_TIMESTAMP
   );
 #+END_SRC

 #+NAME: index the raw_audit_event
 #+BEGIN_SRC sql-mode :results silent
 CREATE INDEX idx_conf_audit_event_endpoint  ON audit_event(endpoint);
 CREATE INDEX idx_conf_audit_event_test_hit ON audit_event(test_hit);
 CREATE INDEX idx_conf_audit_event_conf_test_hit ON audit_event(conf_test_hit);
 #+END_SRC

You can see the logic for how these tables ar epopulated in our loading functions
** Create loading functions
*** load open api
   #+NAME: load_open_api.py
   #+BEGIN_SRC python :results output
     from string import Template
     import json
     import time
     import datetime
     from urllib.request import urlopen, urlretrieve
     from snoopUtils import determine_bucket_job, fetch_swagger
     K8S_REPO_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/"
     OPEN_API_PATH = "/api/openapi-spec/swagger.json"

     release_dates = {
       "v1.0.0": "2015-07-10",
       "v1.1.0": "2015-11-09",
       "v1.2.0": "2016-03-16",
       "v1.3.0": "2016-07-01",
       "v1.4.0": "2016-09-26",
       "v1.5.0": "2016-12-12",
       "v1.6.0": "2017-03-28",
       "v1.7.0": "2017-06-30",
       "v1.8.0": "2017-08-28",
       "v1.9.0": "2017-12-15",
       "v1.10.0": "2018-03-26",
       "v1.11.0":  "2018-06-27",
       "v1.12.0": "2018-09-27",
       "v1.13.0": "2018-12-03" ,
       "v1.14.0": "2019-03-25",
       "v1.15.0": "2019-06-19",
       "v1.16.0": "2019-09-18",
       "v1.17.0": "2019-12-07",
       "v1.18.0": "2020-03-25"
     }
     if custom_release is not None:
       release = custom_release
       open_api_url = K8S_REPO_URL + release + OPEN_API_PATH
       open_api = json.loads(urlopen(open_api_url).read().decode('utf-8')) # may change this to ascii
       rd = release_dates[release]
       release_date = time.mktime(datetime.datetime.strptime(rd, "%Y-%m-%d").timetuple())
     else:
       bucket, job = determine_bucket_job()
       swagger, metadata, commit_hash = fetch_swagger(bucket, job)
       open_api = swagger
       open_api_url = K8S_REPO_URL + commit_hash + OPEN_API_PATH
       release_date = int(metadata['timestamp'])
       release = metadata["version"].split('-')[0].replace('v','')

     sql = Template("""
        WITH open AS (
          SELECT '${open_api}'::jsonb as api_data)
            INSERT INTO open_api(
              release,
              release_date,
              endpoint,
              level,
              category,
              path,
              k8s_group,
              k8s_version,
              k8s_kind,
              k8s_action,
              deprecated,
              description,
              spec
            )
        SELECT
          trim(leading 'v' from '${release}') as release,
          to_timestamp(${release_date}) as release_date,
          (d.value ->> 'operationId'::text) as endpoint,
          CASE
            WHEN paths.key ~~ '%alpha%' THEN 'alpha'
            WHEN paths.key ~~ '%beta%' THEN 'beta'
            ELSE 'stable'
          END AS level,
          split_part((cat_tag.value ->> 0), '_'::text, 1) AS category,
          paths.key AS path,
          ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'group'::text) AS k8s_group,
          ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'version'::text) AS k8s_version,
          ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'kind'::text) AS k8s_kind,
          (d.value ->> 'x-kubernetes-action'::text) AS k8s_action,
          CASE
            WHEN (lower((d.value ->> 'description'::text)) ~~ '%deprecated%'::text) THEN true
            ELSE false
          END AS deprecated,
          (d.value ->> 'description'::text) AS description,
          '${open_api_url}' as spec
          FROM
              open
               , jsonb_each((open.api_data -> 'paths'::text)) paths(key, value)
               , jsonb_each(paths.value) d(key, value)
               , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
         ORDER BY paths.key;
                   """).substitute(release = release,
                                   release_date = release_date,
                                   open_api = json.dumps(open_api).replace("'","''"),
                                   open_api_url = open_api_url)
      #+END_SRC
   #+NAME: load_open_api.sql
   #+BEGIN_SRC sql-mode :results silent
     set role dba;
     DROP FUNCTION IF EXISTS load_open_api;
     CREATE OR REPLACE FUNCTION load_open_api (
       custom_release text default null
       )
     RETURNS text AS $$
     <<load_open_api.py>>
     plpy.execute((sql))
     $$ LANGUAGE plpython3u ;
     reset role;
      #+END_SRC
*** load tests
    #+NAME: load_tests
    #+BEGIN_SRC sql-mode :results silent
      set role dba;
      DROP FUNCTION IF EXISTS load_tests;
      CREATE OR REPLACE FUNCTION load_tests()
      RETURNS text AS $$
      from string import Template
      import json
      import yaml
      from urllib.request import urlopen, urlretrieve

      TESTS_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/master/test/conformance/testdata/conformance.yaml"
      tests = json.dumps(yaml.safe_load(urlopen(TESTS_URL)))
      sql = Template("""
                    WITH jsonb_array AS (
                    SELECT jsonb_array_elements('${tests}'::jsonb) as test_data)
                    INSERT INTO test_info(testname, codename, release, description, file)
                       SELECT
                       (test_data->>'testname') as testname,
                       (test_data->>'codename') as codename,
                       CASE
                         WHEN ((test_data->>'release') = '') THEN '1.19.0'
                         WHEN ((test_data->>'release') like '%,%')
                           THEN trim(leading 'v' from split_part((test_data->>'release'), ', ', 2))||'.0'
                         ELSE trim(leading 'v' from (test_data->>'release')) ||'.0'
                       END as release,
                       (test_data->>'description') as description,
                       (test_data->>'file') as file
                       from jsonb_array;
                    """).substitute(tests = tests.replace("'","''"))
      try:
          plpy.execute(sql)
          return 'conformance.yaml loaded into conformance.tests_info!'
      except Exception as e:
          return 'error occured: ', e
      $$ LANGUAGE plpython3u ;
      reset role;
       #+END_SRC
*** load audit events
     #+NAME: load_audit_events.sql
     #+BEGIN_SRC sql-mode :noweb yes :results silent
       set role dba;
       CREATE OR REPLACE FUNCTION load_audit_events(
         custom_bucket text default null,
         custom_job text default null)
         RETURNS text AS $$
         from string import Template
         from snoopUtils import determine_bucket_job, download_and_process_auditlogs, fetch_swagger

         bucket, job = determine_bucket_job(custom_bucket, custom_job)
         auditlog_file = download_and_process_auditlogs(bucket, job)
         _, metadata, _ = fetch_swagger(bucket, job)
         release_date = int(metadata['timestamp'])
         release = metadata["version"].split('-')[0].replace('v','')

         sql = Template("""
           CREATE TEMPORARY TABLE audit_event_import(data jsonb not null) ;
           COPY audit_event_import(data)
           FROM '${audit_logfile}' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');

           INSERT INTO audit_event(release, release_date,
                                   audit_id, endpoint,
                                   useragent, test,
                                   test_hit, conf_test_hit,
                                   data)

           SELECT trim(leading 'v' from '${release}') as release,
                   '${release_date}',
                   (raw.data ->> 'auditID'),
                   (raw.data ->> 'operationId') as endpoint,
                   (raw.data ->> 'userAgent') as useragent,
                   CASE
                     WHEN ((raw.data ->> 'userAgent') like 'e2e.test%')
                       THEN trim(split_part((raw.data->>'userAgent'), '--'::text, 2))
                     ELSE null
                   END as test,
                   ((raw.data ->> 'userAgent') like 'e2e.test%') as test_hit,
                   ((raw.data ->> 'userAgent') like '%[Conformance]%') as conf_test_hit,
                   raw.data
             FROM audit_event_import raw;
                   """).substitute(
                       audit_logfile = auditlog_file,
                       release = release,
                       release_date = release_date,
                   )
         try:
             plpy.execute(sql)
             return "it worked"
         except plpy.SPIError as plpyError:
             print("something went wrong with plpy: ")
             return plpyError
         except:
             return "something unknown went wrong"
         $$ LANGUAGE plpython3u ;
         reset role;
     #+END_SRC
** Import data using loading functions
    #+NAME: load open_api
    #+begin_src sql-mode :results silent
      WITH releases AS (
        SELECT column1 as release
          FROM (VALUES
                ('v1.9.0'),
                ('v1.10.0'),
                ('v1.11.0'),
                ('v1.12.0'),
                ('v1.13.0'),
                ('v1.14.0'),
                ('v1.15.0'),
                ('v1.16.0'),
                ('v1.17.0'),
                ('v1.18.0')
          ) as rlist
        )
  SELECT f.*
    FROM
        releases r
      , LATERAL load_open_api(r.release) f
        ;
#+end_src


#+begin_src sql-mode
  select * from load_open_api();
#+end_src

    #+NAME: Load test_info
    #+begin_src sql-mode :results silent
    select * from load_tests();
    #+end_src

    #+NAME: load audit_event
    #+begin_src sql-mode :results silent
    select * from load_audit_events(null, '1270783097696161796');
    #+end_src

** Create Views
*** stable endpoint first

   #+NAME: Stable Endpoint first
   #+begin_src sql-mode :results silent
     CREATE MATERIALIZED VIEW stable_endpoint_first AS
     SELECT DISTINCT
       oa.endpoint,
       (array_agg(test.release order by string_to_array(test.release, '.')::int[]))[1] as first_conformance_test,
       (array_agg(test.testname order by string_to_array(test.release, '.')::int[]))[1] as test,
       (array_agg(test.codename order by string_to_array(test.release, '.')::int[]))[1] as codename,
       (array_agg(test.file order by string_to_array(test.release, '.')::int[]))[1] as file,
       (array_agg(oa.release order by string_to_array(oa.release, '.')::int[]))[1] as first_release
       FROM
           open_api oa
           left join audit_event ae using(endpoint)
           LEFT JOIN test_info test on (ae.test = test.codename)
        WHERE oa.level = 'stable'
        GROUP BY 1
        ;
   #+end_src

*** conformance progress
    #+begin_src sql-mode
      CREATE VIEW conformance_progress AS
      WITH current_stable_endpoints AS (
        SELECT
          open_api.endpoint
          FROM
              open_api
         WHERE
           release = '1.19.0'
           AND level = 'stable'
           AND deprecated is false
      ), endpoints_per_release AS (
        SELECT
          release,
          endpoint
          FROM
              open_api
              NATURAL INNER JOIN current_stable_endpoints
      )
      SELECT
        release,
        count(*) as stable_endpoints,
        count(*) FILTER (WHERE epr.release = firsts.first_release) as rel_endpoints,
        count(*) FILTER (WHERE epr.release = firsts.first_release AND epr.release = firsts.first_conformance_test) as rel_endpoints_conf_tested,
        count(*) FILTER (WHERE epr.release = firsts.first_release AND firsts.first_conformance_test IS NULL) as rel_endpoints_still_untested,
        count(*) FILTER (WHERE firsts.first_conformance_test IS NULL) as total_endpoints_still_untested
        FROM
            endpoints_per_release epr
              LEFT JOIN stable_endpoint_first firsts ON (epr.endpoint = firsts.endpoint)
       GROUP BY 1
          ORDER BY string_to_array(release, '.')::int[]
                ;
    #+end_src

    #+RESULTS:
    #+begin_SRC example
    CREATE VIEW
    #+end_SRC

    #+begin_src sql-mode
  select * from conformance_progress;
    #+end_src

    #+RESULTS:
    #+begin_SRC example
     release | stable_endpoints | rel_endpoints | rel_endpoints_conf_tested | rel_endpoints_still_untested | total_endpoints_still_untested
    ---------+------------------+---------------+---------------------------+------------------------------+--------------------------------
     1.9.0   |              361 |           361 |                        25 |                          252 |                            252
     1.10.0  |              370 |             9 |                         0 |                            5 |                            257
     1.11.0  |              372 |             2 |                         0 |                            2 |                            259
     1.12.0  |              373 |             1 |                         0 |                            1 |                            260
     1.13.0  |              383 |            10 |                         0 |                           10 |                            270
     1.14.0  |              401 |            18 |                         0 |                            9 |                            279
     1.15.0  |              401 |             0 |                         0 |                            0 |                            279
     1.16.0  |              429 |            28 |                        22 |                            2 |                            281
     1.17.0  |              437 |             8 |                         0 |                            8 |                            289
     1.18.0  |              444 |             7 |                         0 |                            7 |                            296
     1.19.0  |              458 |            14 |                        13 |                            0 |                            296
    (11 rows)

    #+end_SRC

* create json
  #+begin_src sql-mode
    begin;
    \t
    \a
    \o data.json
    select json_agg(t) from (
      select distinct
      open_api.endpoint,
      case
        when array_agg(test) filter (where test is not null) is not null
        then array_agg(test) filter (where test is not null)
        else '{}'
      END as tests
      from open_api
      left join endpoint_and_test using(endpoint)
      group by 1
      ) t;
    \o
    \a
    \t
    commit;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
  BEGIN
  Tuples only is on.
  Output format is unaligned.
  #+end_SRC


#+begin_src sql-mode
  begin;
  \t
  \a
  \o progress.json
  select json_agg(progress) from (
    select * from conformance_progress
  ) progress;
  \o
  \a
  \t
  commit;

#+end_src

#+RESULTS:
#+begin_SRC example
BEGIN
Tuples only is on.
Output format is unaligned.
postgres=# postgres=# Output format is aligned.
Tuples only is off.
COMMIT
#+end_SRC


* scratch
  #+begin_src sql-mode
  refresh materialized view stable_endpoint_first;
  #+end_src

  #+RESULTS:
  #+begin_SRC example
  REFRESH MATERIALIZED VIEW
  #+end_SRC

  #+begin_src sql-mode
    with current_eligible_endpoints as
    (
      select endpoint
      from open_api
        where release = '1.19.0'
        and level = 'stable'
        and deprecated is false
    ), endpoints_per_release as (
      select release, endpoint
      from       open_api
      inner join current_eligible_endpoints using(endpoint)
    )
    select
      release,
      count(distinct endpoint) as total_endpoints,
      count(distinct endpoint) FILTER (WHERE epr.release = firsts.first_release) as new_endpoints,
      count(distinct endpoint) FILTER (WHERE epr.release = firsts.first_conformance_test) as new_endpoints_tested
      from      endpoints_per_release epr
      join stable_endpoint_first firsts using(endpoint)
      group by 1
      order by string_to_array(release, '.')::int[]
    ;
  #+end_src


#+begin_src sql-mode
  select distinct test, file from stable_endpoint_first where first_conformance_test = '1.19.0' order by test;
#+end_src

#+RESULTS:
#+begin_SRC example
                   test                   |                file
------------------------------------------+-------------------------------------
 aggregator-supports-the-sample-apiserver | test/e2e/apimachinery/aggregator.go
 CertificateSigningRequest API            | test/e2e/auth/certificates.go
 Deployment Proportional Scaling          | test/e2e/apps/deployment.go
 PodTemplate lifecycle                    | test/e2e/common/podtemplates.go
 ServiceAccount lifecycle test            | test/e2e/auth/service_accounts.go
(5 rows)

#+end_SRC
