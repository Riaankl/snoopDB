#+TITLE: Our DB
#+PROPERTY: header-args:sql-mode :product postgres :noweb yes :comments off

* Purpose
  This document holds the definitions for tables, views, and functions we find perennially  useful, and so we save them as sql files to be quickly loaded for your db.
* Tables
** open_api
   #+NAME: open_api definition
   #+begin_src sql-mode :results silent :tangle ./table-open_api.sql
     create table open_api
     (
       release text,
       release_date timestamp,
       endpoint text,
       level text,
       category text,
       path text,
       k8s_group text,
       k8s_version text,
       k8s_kind text,
       k8s_action text,
       deprecated boolean,
       description text,
       spec text,
       primary key (release, endpoint)
     );
   #+end_src
** test
    #+NAME: create tests_info table
    #+begin_src sql-mode :results silent :tangle ./table-test.sql
      create table test
        (
          testname text,
          codename text,
          release text,
          description text,
          file text
      );
    #+end_src
** audit event
 #+NAME: audit_event
 #+BEGIN_SRC sql-mode :results silent :tangle ./table-audit_event.sql
   CREATE UNLOGGED TABLE audit_event (
     release text,
     release_date text,
     audit_id text NOT NULL,
     endpoint text,
     useragent text,
     test text,
     test_hit boolean,
     conf_test_hit boolean,
     data jsonb NOT NULL,
     id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
     ingested_at timestamp DEFAULT CURRENT_TIMESTAMP
   );
 #+END_SRC
* Functions
** load open api
** load tests
   #+NAME: load_tests
   #+BEGIN_SRC sql-mode :results silent :tangle ../fn-load_tests.sql
     set role dba;
     DROP FUNCTION IF EXISTS load_tests;
     CREATE OR REPLACE FUNCTION load_tests()
     RETURNS text AS $$
     from string import Template
     import json
     import yaml
     from urllib.request import urlopen, urlretrieve

     TESTS_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/master/test/conformance/testdata/conformance.yaml"
     tests = json.dumps(yaml.safe_load(urlopen(TESTS_URL)))
     sql = Template("""
                   WITH jsonb_array AS (
                   SELECT jsonb_array_elements('${tests}'::jsonb) as test_data)
                   INSERT INTO test(testname, codename, release, description, file)
                      SELECT
                      (test_data->>'testname') as testname,
                      (test_data->>'codename') as codename,
                      CASE
                        WHEN ((test_data->>'release') = '') THEN '1.9.0'
                        WHEN ((test_data->>'release') like '%,%')
                          THEN trim(leading 'v' from split_part((test_data->>'release'), ', ', 2))||'.0'
                        ELSE trim(leading 'v' from (test_data->>'release')) ||'.0'
                      END as release,
                      (test_data->>'description') as description,
                      (test_data->>'file') as file
                      from jsonb_array;
                   """).substitute(tests = tests.replace("'","''"))
     try:
         plpy.execute(sql)
         return 'conformance.yaml loaded into test!'
     except Exception as e:
         return 'error occured: ', e
     $$ LANGUAGE plpython3u ;
     reset role;
      #+END_SRC
** load audit events
    #+NAME: load_audit_events.sql
    #+BEGIN_SRC sql-mode :noweb yes :results silent :tangle ../fn-load_audit_events.sql
      set role dba;
      CREATE OR REPLACE FUNCTION load_audit_events(
        custom_bucket text default null,
        custom_job text default null)
        RETURNS text AS $$
        from string import Template
        from snoopUtils import determine_bucket_job, download_and_process_auditlogs, fetch_swagger

        bucket, job = determine_bucket_job(custom_bucket, custom_job)
        auditlog_file = download_and_process_auditlogs(bucket, job)
        _, metadata, _ = fetch_swagger(bucket, job)
        release_date = int(metadata['timestamp'])
        release = metadata["version"].split('-')[0].replace('v','')

        sql = Template("""
          CREATE TEMPORARY TABLE audit_event_import(data jsonb not null) ;
          COPY audit_event_import(data)
          FROM '${audit_logfile}' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');

          INSERT INTO audit_event(release, release_date,
                                  audit_id, endpoint,
                                  useragent, test,
                                  test_hit, conf_test_hit,
                                  data)

          SELECT trim(leading 'v' from '${release}') as release,
                  '${release_date}',
                  (raw.data ->> 'auditID'),
                  (raw.data ->> 'operationId') as endpoint,
                  (raw.data ->> 'userAgent') as useragent,
                  CASE
                    WHEN ((raw.data ->> 'userAgent') like 'e2e.test%')
                      THEN trim(split_part((raw.data->>'userAgent'), '--'::text, 2))
                    ELSE null
                  END as test,
                  ((raw.data ->> 'userAgent') like 'e2e.test%') as test_hit,
                  ((raw.data ->> 'userAgent') like '%[Conformance]%') as conf_test_hit,
                  raw.data
            FROM audit_event_import raw;
                  """).substitute(
                      audit_logfile = auditlog_file,
                      release = release,
                      release_date = release_date,
                  )
        try:
            plpy.execute(sql)
            return "it worked"
        except plpy.SPIError as plpyError:
            print("something went wrong with plpy: ")
            return plpyError
        except:
            return "something unknown went wrong"
        $$ LANGUAGE plpython3u ;
        reset role;
    #+END_SRC
   #+NAME: load_open_api.py
   #+BEGIN_SRC python :results silent
     from string import Template
     import json
     import time
     import datetime
     from urllib.request import urlopen, urlretrieve
     from snoopUtils import determine_bucket_job, fetch_swagger
     K8S_REPO_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/"
     OPEN_API_PATH = "/api/openapi-spec/swagger.json"

     release_dates = {
       "v1.0.0": "2015-07-10",
       "v1.1.0": "2015-11-09",
       "v1.2.0": "2016-03-16",
       "v1.3.0": "2016-07-01",
       "v1.4.0": "2016-09-26",
       "v1.5.0": "2016-12-12",
       "v1.6.0": "2017-03-28",
       "v1.7.0": "2017-06-30",
       "v1.8.0": "2017-08-28",
       "v1.9.0": "2017-12-15",
       "v1.10.0": "2018-03-26",
       "v1.11.0":  "2018-06-27",
       "v1.12.0": "2018-09-27",
       "v1.13.0": "2018-12-03" ,
       "v1.14.0": "2019-03-25",
       "v1.15.0": "2019-06-19",
       "v1.16.0": "2019-09-18",
       "v1.17.0": "2019-12-07",
       "v1.18.0": "2020-03-25"
     }
     if custom_release is not None:
       release = custom_release
       open_api_url = K8S_REPO_URL + release + OPEN_API_PATH
       open_api = json.loads(urlopen(open_api_url).read().decode('utf-8')) # may change this to ascii
       rd = release_dates[release]
       release_date = time.mktime(datetime.datetime.strptime(rd, "%Y-%m-%d").timetuple())
     else:
       bucket, job = determine_bucket_job()
       swagger, metadata, commit_hash = fetch_swagger(bucket, job)
       open_api = swagger
       open_api_url = K8S_REPO_URL + commit_hash + OPEN_API_PATH
       release_date = int(metadata['timestamp'])
       release = metadata["version"].split('-')[0].replace('v','')

     sql = Template("""
        WITH open AS (
          SELECT '${open_api}'::jsonb as api_data)
            INSERT INTO open_api(
              release,
              release_date,
              endpoint,
              level,
              category,
              path,
              k8s_group,
              k8s_version,
              k8s_kind,
              k8s_action,
              deprecated,
              description,
              spec
            )
        SELECT
          trim(leading 'v' from '${release}') as release,
          to_timestamp(${release_date}) as release_date,
          (d.value ->> 'operationId'::text) as endpoint,
          CASE
            WHEN paths.key ~~ '%alpha%' THEN 'alpha'
            WHEN paths.key ~~ '%beta%' THEN 'beta'
            ELSE 'stable'
          END AS level,
          split_part((cat_tag.value ->> 0), '_'::text, 1) AS category,
          paths.key AS path,
          ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'group'::text) AS k8s_group,
          ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'version'::text) AS k8s_version,
          ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'kind'::text) AS k8s_kind,
          (d.value ->> 'x-kubernetes-action'::text) AS k8s_action,
          CASE
            WHEN (lower((d.value ->> 'description'::text)) ~~ '%deprecated%'::text) THEN true
            ELSE false
          END AS deprecated,
          (d.value ->> 'description'::text) AS description,
          '${open_api_url}' as spec
          FROM
              open
               , jsonb_each((open.api_data -> 'paths'::text)) paths(key, value)
               , jsonb_each(paths.value) d(key, value)
               , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
         ORDER BY paths.key;
                   """).substitute(release = release,
                                   release_date = release_date,
                                   open_api = json.dumps(open_api).replace("'","''"),
                                   open_api_url = open_api_url)
      #+END_SRC

   #+NAME: load_open_api.sql
   #+BEGIN_SRC sql-mode :results silent :tangle ./fn-load_open_api.sql
     set role dba;
     DROP FUNCTION IF EXISTS load_open_api;
     CREATE OR REPLACE FUNCTION load_open_api (
       custom_release text default null
       )
     RETURNS text AS $$
     <<load_open_api.py>>
     try:
       plpy.execute((sql))
       return "{} open api is loaded".format(custom_release if custom_release else "current")
     except:
       return "an error occurred"
     $$ LANGUAGE plpython3u ;
     reset role;
      #+END_SRC

* Views
** materialized: stable_endpoint_first
  #+NAME: define stable_endpoint_first
  #+begin_src sql-mode :results silent :tangle ./matview-stable_endpoint_first.sql
    create materialized view stable_endpoint_first as
    select distinct
      oa.endpoint,
      (array_agg(test.release order by test.release::semver))[1] as first_conformance_test,
      (array_agg(test.testname order by test.release::semver))[1] as test,
      (array_agg(test.codename order by test.release::semver))[1] as codename,
      (array_agg(test.file order by test.release::semver))[1] as file,
      (array_agg(oa.release order by oa.release::semver))[1] as first_release,
      array_remove((array_agg(distinct test.release::semver order by test.release::semver)), null) as all_test_releases
      from
          open_api oa
          left join audit_event ae using(endpoint)
          left join test on (ae.test = test.codename)
      where oa.level = 'stable'
      and deprecated is false
      group by 1
      ;
  #+end_src
** conformance progress
  #+NAME: conformance progress
  #+begin_src sql-mode :tangle ./view-conformance_progress.sql
    create view conformance_progress as
      with current_stable_endpoints as (
        select endpoint
          from open_api
         where release = '1.19.0'
           and level = 'stable'
        except
          select endpoint
          from open_api
          where path like '%volume%'
              or path like '%storage%'
              or deprecated is true
              or k8s_kind = 'ComponentStatus'
              or (k8s_kind = 'Node' and k8s_action = any('{"delete", "post"}'))
      ), endpoints_per_release as (-- this filters out endpoints that were dropped after the release
        select release, endpoint
          from       open_api
          inner join current_stable_endpoints using(endpoint)
      )
      select distinct
        epr.release::semver,
        count(*) filter (where epr.release = firsts.first_release) as new_endpoints,

        (select count(*) from test where test.release = epr.release) as new_tests,

        count(*) filter (
          where epr.release = firsts.first_release
          and firsts.all_test_releases @> array[epr.release::semver]
        )
        as new_endpoints_promoted_with_tests,

        count(*) filter (
          where epr.release = firsts.first_release
          and firsts.first_conformance_test = firsts.first_release
        )
          as new_endpoints_covered_by_new_tests,

        count(*) filter (
        where firsts.first_release = epr.release
        and firsts.first_conformance_test::semver < epr.release::semver
        )
          as new_endpoints_covered_by_old_tests,
        count(*) filter (
          where firsts.first_release::semver < epr.release::semver
            and firsts.first_conformance_test = epr.release
        )
          as old_endpoints_covered_by_new_tests,

        count(*) as total_endpoints,

        count(*) filter (
          where firsts.first_release::semver <= epr.release::semver
          and firsts.first_conformance_test::semver <= epr.release::semver
        )
          as total_tested_endpoints,

        count(*) filter (
          where firsts.first_release = epr.release
          AND firsts.first_conformance_test is null
        ) endpoints_still_untested_today

      from      endpoints_per_release epr
      left join stable_endpoint_first firsts on (epr.endpoint = firsts.endpoint)
     group by epr.release
     order by epr.release::semver;
    #+end_src


* helper src blocks
** Load old open_api
    #+NAME: load past open_api
    #+begin_src sql-mode :results silent
      with releases as (
        select column1 as release
          from (values
          ('v1.8.0'),
          ('v1.9.0'),
          ('v1.10.0'),
          ('v1.11.0'),
          ('v1.12.0'),
          ('v1.13.0'),
          ('v1.14.0'),
          ('v1.15.0'),
          ('v1.16.0'),
          ('v1.17.0'),
          ('v1.18.0')
          ) as rlist
      )
      select f.*
        from
        releases r
        , lateral load_open_api(r.release) f(loading_results)
      ;
#+end_src
** Progress to Json
   We'll put this into our viz/resources to be used by our page maker.
   #+NAME: Progress to Json
   #+begin_src sql-mode :tangle progress-to-json.sql
    begin;
    \t
    \a
    \o ../viz/resources/progress.json
      select json_agg(json_build_object(
      'release', release,
      'total', json_build_object(
        'endpoints', total_endpoints,
        'tested', total_tested_endpoints,
        'new', new_endpoints,
        'new_with_tests', new_endpoints_promoted_with_tests,
        'new_tested', new_endpoints_covered_by_new_tests + new_endpoints_covered_by_old_tests,
        'still_untested', endpoints_still_untested_today
      )
    ))from conformance_progress where release != '1.8.0';
    \o
    \a
    \t
    commit;
  #+end_src

  #+RESULTS: Progress to Json
  #+begin_SRC example
  BEGIN
  Tuples only is on.
  Output format is unaligned.
  #+end_SRC
