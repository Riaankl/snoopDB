#+TITLE: Tables, Views, Functions
#+PROPERTY: header-args:sql-mode :product postgres :noweb yes :comments no

* Purpose
  Define all the default tables, views, and functions for the snoop database.
  All definitions here will be tangled into our initdb.
  Every table, view, and function should be commented before tangled
* Tables
** open_api
   :PROPERTIES:
   :header-args: :tangle ./initdb/02_table_open_api.sql
   :END:
   #+NAME: openapi
   #+begin_src sql-mode
     create table open_api
       (
         release text,
         release_date timestamp,
         endpoint text,
         level text,
         category text,
         path text,
         k8s_group text,
         k8s_version text,
         k8s_kind text,
         k8s_action text,
         deprecated boolean,
         description text,
         spec text,
         primary key (release, endpoint)
       );

   #+end_src

   #+NAME: open_api comments
   #+begin_src sql-mode
     comment on table open_api is 'Details on k8s endpoints taken from the openapi spec for that release';

     comment on column open_api.release is 'kubernetes release this spec is taken from';
     comment on column open_api.release_date is 'canonical release dat for this k8s release';
     comment on column open_api.endpoint is 'a kubernetes endpoint, the operation_id in the spec';
     comment on column open_api.level is 'level of endpoint: alpha, beta, or stable';
     comment on column open_api.category is 'endpoint category, roughly its group, taken from the first tag in the spec.';
     comment on column open_api.path is 'the http path of the endpoint';
     comment on column open_api.k8s_group is 'k8s group for endpoint';
     comment on column open_api.k8s_version is 'k8s version for endpoint';
     comment on column open_api.k8s_kind  is 'k8s kind  for endpoint';
     comment on column open_api.k8s_action is 'endpoint action, roughly related to an http method';
     comment on column open_api.deprecated is 'is endpoint marked as deprecated?';
     comment on column open_api.description is 'description of endpoint';
     comment on column open_api.spec is 'the url location for this open api spec. will be from github.';

   #+end_src
** audit_event
   :PROPERTIES:
   :header-args: :tangle ./initdb/03_table_audit_event.sql
   :END:

   #+NAME: audit event definition
   #+begin_src sql-mode
     CREATE UNLOGGED TABLE audit_event (
       release text,
       release_date text,
       audit_id text NOT NULL,
       endpoint text,
       useragent text,
       test text,
       test_hit boolean,
       conf_test_hit boolean,
       data jsonb NOT NULL,
       source text,
       id int GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
       ingested_at timestamp DEFAULT CURRENT_TIMESTAMP);

   #+end_src

   #+NAME: audit event comments
   #+begin_src sql-mode
     comment on table audit_event is 'each audit event taken from the logs of an e2e test suite run';

     comment on column audit_event.release is 'release this test suite was run for';
     comment on column audit_event.release_date is 'canonical release, or date of run if version has not been released yet';
     comment on column audit_event.audit_id is 'audit event id as given in log.  Note these are not necessarily unique.';
     comment on column audit_event.endpoint is 'the endpoint hit by this audit event';
     comment on column audit_event.useragent is 'the useragent of the event, stored in events request header';
     comment on column audit_event.test is 'the test codename if it can be extracted from useragent, else null';
     comment on column audit_event.test_hit is 'is this event one where a test is hitting an endpoint, as seen in its useragent?';
     comment on column audit_event.conf_test_hit is 'is this event one where a conformance test is hitting an endpoint?';
     comment on column audit_event.data is 'the full json of the audit event';
     comment on column audit_event.source is 'the url location of the bucket where the test run logs are stored';
     comment on column audit_event.id is 'generated id, this will be unique';
     comment on column audit_event.ingested_at is 'the time at which the audit_event was added to this table';
   #+end_src

** test
   :PROPERTIES:
   :header-args: :tangle ./initdb/04_table_test.sql
   :END:

  #+NAME: Test Definition
  #+begin_src sql-mode
    create table test
      (
        testname text,
        codename text,
        release text,
        description text,
        file text
    );

  #+end_src

  #+NAME: Test Comments
  #+begin_src sql-mode
    comment on table test is 'info for each conformance test as taken from latest conformance.yaml';

    comment on column test.testname is 'The name of the test';
    comment on column test.codename is 'How the test is displayed in code, i.e in the useragent of an audit event';
    comment on column test.release is 'The release in which this test  was promoted to conformance';
    comment on column test.description is 'A description of this test';
    comment on column test.file is 'The file in kubernetes/kubernetes where this test is defined';
  #+end_src

* Functions
** load_open_api
   :PROPERTIES:
   :header-args: :tangle ./initdb/05_fn_load_open_api.sql
   :END:
    #+NAME: load_open_api definition
    #+begin_src sql-mode
      CREATE OR REPLACE FUNCTION load_open_api (
        custom_release text default null
        )
      RETURNS text AS $$
      from string import Template
      import json
      import time
      import datetime
      from urllib.request import urlopen, urlretrieve
      from snoopUtils import determine_bucket_job, fetch_swagger
      K8S_REPO_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/"
      OPEN_API_PATH = "/api/openapi-spec/swagger.json"

      release_dates = {
        "v1.0.0": "2015-07-10",
        "v1.1.0": "2015-11-09",
        "v1.2.0": "2016-03-16",
        "v1.3.0": "2016-07-01",
        "v1.4.0": "2016-09-26",
        "v1.5.0": "2016-12-12",
        "v1.6.0": "2017-03-28",
        "v1.7.0": "2017-06-30",
        "v1.8.0": "2017-08-28",
        "v1.9.0": "2017-12-15",
        "v1.10.0": "2018-03-26",
        "v1.11.0":  "2018-06-27",
        "v1.12.0": "2018-09-27",
        "v1.13.0": "2018-12-03" ,
        "v1.14.0": "2019-03-25",
        "v1.15.0": "2019-06-19",
        "v1.16.0": "2019-09-18",
        "v1.17.0": "2019-12-07",
        "v1.18.0": "2020-03-25"
      }
      if custom_release is not None:
        release = custom_release
        open_api_url = K8S_REPO_URL + release + OPEN_API_PATH
        open_api = json.loads(urlopen(open_api_url).read().decode('utf-8')) # may change this to ascii
        rd = release_dates[release]
        release_date = time.mktime(datetime.datetime.strptime(rd, "%Y-%m-%d").timetuple())
      else:
        bucket, job = determine_bucket_job()
        swagger, metadata, commit_hash = fetch_swagger(bucket, job)
        open_api = swagger
        open_api_url = K8S_REPO_URL + commit_hash + OPEN_API_PATH
        release_date = int(metadata['timestamp'])
        release = metadata["version"].split('-')[0].replace('v','')

      sql = Template("""
         WITH open AS (
           SELECT '${open_api}'::jsonb as api_data)
             INSERT INTO open_api(
               release,
               release_date,
               endpoint,
               level,
               category,
               path,
               k8s_group,
               k8s_version,
               k8s_kind,
               k8s_action,
               deprecated,
               description,
               spec
             )
         SELECT
           trim(leading 'v' from '${release}') as release,
           to_timestamp(${release_date}) as release_date,
           (d.value ->> 'operationId'::text) as endpoint,
           CASE
             WHEN paths.key ~~ '%alpha%' THEN 'alpha'
             WHEN paths.key ~~ '%beta%' THEN 'beta'
             ELSE 'stable'
           END AS level,
           split_part((cat_tag.value ->> 0), '_'::text, 1) AS category,
           paths.key AS path,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'group'::text) AS k8s_group,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'version'::text) AS k8s_version,
           ((d.value -> 'x-kubernetes-group-version-kind'::text) ->> 'kind'::text) AS k8s_kind,
           (d.value ->> 'x-kubernetes-action'::text) AS k8s_action,
           CASE
             WHEN (lower((d.value ->> 'description'::text)) ~~ '%deprecated%'::text) THEN true
             ELSE false
           END AS deprecated,
           (d.value ->> 'description'::text) AS description,
           '${open_api_url}' as spec
           FROM
               open
                , jsonb_each((open.api_data -> 'paths'::text)) paths(key, value)
                , jsonb_each(paths.value) d(key, value)
                , jsonb_array_elements((d.value -> 'tags'::text)) cat_tag(value)
          ORDER BY paths.key;
                    """).substitute(release = release,
                                    release_date = release_date,
                                    open_api = json.dumps(open_api).replace("'","''"),
                                    open_api_url = open_api_url)
      try:
        plpy.execute((sql))
        return "{} open api is loaded".format(custom_release if custom_release else "current")
      except:
        return "an error occurred"
      $$ LANGUAGE plpython3u ;
      reset role;
    #+end_src

    #+NAME: load_open_api comments
    #+begin_src sql-mode

      comment on function load_open_api is 'loads given release to open_api table.  Can pass release as "v.X.XX.X" to load specific release, otherwise loads latest';
    #+end_src
** load_audit_events
   :PROPERTIES:
   :header-args: :tangle ./initdb/06_fn_load_audit_events.sql
   :END:
    #+NAME: load_audit_events definition
    #+begin_src sql-mode
      CREATE OR REPLACE FUNCTION load_audit_events(
        custom_bucket text default null,
        custom_job text default null)
        RETURNS text AS $$
        from string import Template
        from snoopUtils import determine_bucket_job, download_and_process_auditlogs, fetch_swagger

        bucket, job = determine_bucket_job(custom_bucket, custom_job)
        auditlog_file = download_and_process_auditlogs(bucket, job)
        _, metadata, _ = fetch_swagger(bucket, job)
        release_date = int(metadata['timestamp'])
        release = metadata["version"].split('-')[0].replace('v','')
        num = release.replace('.','')

        sql = Template("""
          CREATE TEMPORARY TABLE audit_event_import${job}(data jsonb not null) ;
          COPY audit_event_import${job}(data)
          FROM '${audit_logfile}' (DELIMITER e'\x02', FORMAT 'csv', QUOTE e'\x01');

          INSERT INTO audit_event(release, release_date,
                                  audit_id, endpoint,
                                  useragent, test,
                                  test_hit, conf_test_hit,
                                  data, source)

          SELECT trim(leading 'v' from '${release}') as release,
                  '${release_date}',
                  (raw.data ->> 'auditID'),
                  (raw.data ->> 'operationId') as endpoint,
                  (raw.data ->> 'userAgent') as useragent,
                  CASE
                    WHEN ((raw.data ->> 'userAgent') like 'e2e.test%')
                      THEN trim(split_part((raw.data->>'userAgent'), '--'::text, 2))
                    ELSE null
                  END as test,
                  ((raw.data ->> 'userAgent') like 'e2e.test%') as test_hit,
                  ((raw.data ->> 'userAgent') like '%[Conformance]%') as conf_test_hit,
                  raw.data,
                  'https://prow.k8s.io/view/gcs/kubernetes-jenkins/logs/${bucket}/${job}' as source
            FROM audit_event_import${job} raw;
                  """).substitute(
                      audit_logfile = auditlog_file,
                      release = release,
                      bucket = bucket,
                      job = job,
                      release_date = release_date
                  )
        try:
            plpy.execute(sql)
            return "it worked"
        except plpy.SPIError as plpyError:
            print("something went wrong with plpy: ")
            return plpyError
        except:
            return "something unknown went wrong"
        $$ LANGUAGE plpython3u ;
        reset role;
    #+end_src

    #+NAME: load_open_api comments
    #+begin_src sql-mode
      comment on function load_audit_events is 'loads all audit events from given bucket, job.  if neither given, loads latest successful job from sig-release blocking. if just bucket given, loads latest successful job for that bucket.';
    #+end_src
** load_tests
   :PROPERTIES:
   :header-args: :tangle ./initdb/07_fn_load_tests.sql
   :END:
   #+NAME: load_tests definition
   #+begin_src sql-mode
     CREATE OR REPLACE FUNCTION load_tests()
     RETURNS text AS $$
     from string import Template
     import json
     import yaml
     from urllib.request import urlopen, urlretrieve

     TESTS_URL = "https://raw.githubusercontent.com/kubernetes/kubernetes/master/test/conformance/testdata/conformance.yaml"
     tests = json.dumps(yaml.safe_load(urlopen(TESTS_URL)))
     sql = Template("""
                   WITH jsonb_array AS (
                   SELECT jsonb_array_elements('${tests}'::jsonb) as test_data)
                   INSERT INTO test(testname, codename, release, description, file)
                      SELECT
                      (test_data->>'testname') as testname,
                      (test_data->>'codename') as codename,
                      CASE
                        WHEN ((test_data->>'release') = '') THEN '1.9.0'
                        WHEN ((test_data->>'release') like '%,%')
                          THEN trim(leading 'v' from split_part((test_data->>'release'), ', ', 2))||'.0'
                        ELSE trim(leading 'v' from (test_data->>'release')) ||'.0'
                      END as release,
                      (test_data->>'description') as description,
                      (test_data->>'file') as file
                      from jsonb_array;
                   """).substitute(tests = tests.replace("'","''"))
     try:
         plpy.execute(sql)
         return 'conformance.yaml loaded into test!'
     except Exception as e:
         return 'error occured: ', e
     $$ LANGUAGE plpython3u;
   #+end_src

   #+NAME: load_tests comment
   #+begin_src sql-mode

     comment on function load_tests is 'loads latest conformance.yaml into test table';
   #+end_src
* Views
** Release Coverage
   #+begin_src sql-mode
     begin;
       \t
       \a
       \o ../resources/coverage/1.19.0.json
       select row_to_json(c) from (
         select release, open_api.release_date, spec,
            (select source from (select source from audit_event where release = '1.19.0' limit 1) s) as source,
                (
                  select array_to_json(array_agg(row_to_json(e)))
                    from (
                      select endpoint, level, category, path, description,
                             k8s_kind as kind,
                             k8s_version as version,
                             k8s_group as group,
                             k8s_action as action,
                             (count(test_hit) filter(where test_hit is true)>0) as tested,
                             (count(conf_test_hit) filter(where conf_test_hit is true)>0) as conf_tested,
                             array_agg(distinct test) as tests
                        from open_api
                               left join audit_event using(endpoint, release)
                       where release = '1.19.0'
                         and deprecated is false
                         group by endpoint, level, category, path, description, kind,
                                  version, k8s_group, k8s_action
                       order by level desc, endpoint
                    ) e
                ) as endpoints,
                (
                  select array_to_json(array_agg(row_to_json(t)))
                    from (
                      select test, testname, file,
                             test.release,
                             (testname is not null) as conformance_test
                        from      audit_event
                        left join test on(test = codename)
                        where test is not null
                       group by test, testname, file, test.release
                    ) t
                  ) as tests
           from open_api
          where release = '1.19.0'
            group by release, open_api.release_date, spec
       ) c;
       \o
       \a
       \t
       commit;
   #+end_src

* Select Scripts
  These aren't static relations in the db, but scripts we run as part of the db's initialization
** Load all our open_api
   :PROPERTIES:
   :header-args: :tangle ./initdb/08_load_all_open_api.sql
   :END:
   #+NAME: Load all open api
   #+begin_src sql-mode
     begin;
     with releases as (
       select column1 as release
         from (values
         ('v1.8.0'),
         ('v1.9.0'),
         ('v1.10.0'),
         ('v1.11.0'),
         ('v1.12.0'),
         ('v1.13.0'),
         ('v1.14.0')
         ) as rlist
     )
     select f.*
       from
       releases r
       , lateral load_open_api(r.release) f(loading_results);
     select * from load_open_api() f(loading_results);
     commit;

   #+end_src


** Load tests
   :PROPERTIES:
   :header-args: :tangle ./initdb/09_load_all_open_api.sql
   :END:
   #+NAME: load tests
   #+begin_src sql-mode
     begin;
     select * from load_tests();
     commit;
   #+end_src

** Load latest audit_events
** Load latest tests
